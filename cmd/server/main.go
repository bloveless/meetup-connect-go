package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"strings"

	"connectrpc.com/connect"
	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"github.com/go-chi/cors"
	"github.com/lucsky/cuid"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"

	todov1 "connectgo/gen/todo/v1"
	"connectgo/gen/todo/v1/todov1connect" // generated by protoc-gen-connect-go
	"connectgo/web"
)

type ToDoServer struct {
	toDos []*todov1.ToDoItem
}

func (s *ToDoServer) GetToDos(
	ctx context.Context,
	req *connect.Request[todov1.GetToDosRequest],
) (*connect.Response[todov1.GetToDosResponse], error) {
	res := connect.NewResponse(&todov1.GetToDosResponse{
		ToDos: s.toDos,
	})

	res.Header().Set("ToDo-Version", "v1")
	return res, nil
}


func (s *ToDoServer) CreateToDo(
	ctx context.Context,
	req *connect.Request[todov1.CreateToDoRequest],
) (*connect.Response[todov1.CreateToDoResponse], error) {
	log.Println("Request headers: ", req.Header())
	s.toDos = append(s.toDos, &todov1.ToDoItem{
		Id:   cuid.New(),
		ToDo: req.Msg.ToDo,
	})
	res := connect.NewResponse(&todov1.CreateToDoResponse{
		ToDos: s.toDos,
	})
	res.Header().Set("ToDo-Version", "v1")
	return res, nil
}

func (s *ToDoServer) CompleteToDo(
	ctx context.Context,
	req *connect.Request[todov1.CompleteToDoRequest],
) (*connect.Response[todov1.CompleteToDoResponse], error) {
	for _, toDo := range s.toDos {
		if toDo.Id == req.Msg.Id {
			toDo.Completed = true
		}
	}

	res := connect.NewResponse(&todov1.CompleteToDoResponse{
		ToDos: s.toDos,
	})

	res.Header().Set("ToDo-Version", "v1")
	return res, nil
}

func main() {
	r := chi.NewRouter()

	// A good base middleware stack
	r.Use(middleware.RequestID)
	r.Use(middleware.RealIP)
	r.Use(middleware.Logger)
	r.Use(middleware.Recoverer)

	// Basic CORS
	// for more ideas, see: https://developer.github.com/v3/#cross-origin-resource-sharing
	r.Use(cors.Handler(cors.Options{
		// AllowedOrigins:   []string{"https://foo.com"}, // Use this to allow specific origin hosts
		AllowedOrigins: []string{"https://*", "http://*"},
		// AllowOriginFunc:  func(r *http.Request, origin string) bool { return true },
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token", "connect-protocol-version"},
		ExposedHeaders:   []string{"Link"},
		AllowCredentials: false,
		MaxAge:           300, // Maximum value not ignored by any of major browsers
	}))

	todo := &ToDoServer{
		toDos: make([]*todov1.ToDoItem, 0),
	}
	path, handler := todov1connect.NewToDoServiceHandler(todo)
	r.Post(path+"*", handler.(http.HandlerFunc))

	r.Get("/welcome", func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("welcome"))
	})

	err := chi.Walk(r, func(method string, route string, handler http.Handler, middlewares ...func(http.Handler) http.Handler) error {
		fmt.Printf("[%s]: '%s' has %d middlewares\n", method, route, len(middlewares))
		return nil
	})
	if err != nil {
		panic(err)
	}

	assets, err := web.Assets()
	if err != nil {
		panic(err)
	}

	r.Get("/*", func(w http.ResponseWriter, r *http.Request) {
		rctx := chi.RouteContext(r.Context())
		pathPrefix := strings.TrimSuffix(rctx.RoutePattern(), "/*")
		fs := http.StripPrefix(pathPrefix, http.FileServer(http.FS(assets)))
		fs.ServeHTTP(w, r)
	})

	fmt.Println("Listening on localhost:8080")
	err = http.ListenAndServe(
		"localhost:8080",
		// Use h2c so we can serve HTTP/2 without TLS.
		h2c.NewHandler(r, &http2.Server{}),
	)
	if err != nil {
		panic(err)
	}
}
